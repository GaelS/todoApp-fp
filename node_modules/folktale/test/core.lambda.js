'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('jsverify');

var property = _require.property;

var assert = require('assert');
var _ = require('../').core.lambda;

var eqPairs = function eqPairs() {
  for (var _len = arguments.length, xs = Array(_len), _key = 0; _key < _len; _key++) {
    xs[_key] = arguments[_key];
  }

  return xs.reduce(function (p, x) {
    return p.r && (!('v' in p) || p.v === x) ? { r: true, v: x } : /* otherwise */{ r: false };
  }, { r: true }).r;
};

describe('Core.Lambda', function () {
  describe('compose(f, g)', function () {
    property('= f(g(x))', 'integer', function (a) {
      var f = function f(x) {
        return x - 1;
      };
      var g = function g(y) {
        return y * 2;
      };
      return _.compose(f, g)(a) === f(g(a));
    });

    property('Associativity: compose(f, compose(g, h)) = compose(compose(f, g), h)', 'integer', function (a) {
      var f = function f(x) {
        return x - 1;
      };
      var g = function g(x) {
        return x * 2;
      };
      var h = function h(x) {
        return x / 3;
      };
      return _.compose(f, _.compose(g, h))(a) === _.compose(_.compose(f, g), h)(a);
    });
  });

  describe('constant(a)()', function () {
    property('= a', 'nat', function (a) {
      return _.constant(a)() === a;
    });
  });

  describe('identity(a)', function () {
    property('= a', 'nat', function (a) {
      return _.identity(a) === a;
    });
  });

  describe('curry(arity, fn)', function () {
    var f = function f(a, b) {
      return a(b);
    };
    var g = function g(a) {
      return a + 1;
    };
    var h = function h(a) {
      return function (b) {
        return a(b) + 1;
      };
    };
    var i = function i(a, b, c, d) {
      return a + b + c + d;
    };

    it('invoking with fewer arguments yields a new function that takes the rest', function () {
      assert.equal(_typeof(_.curry(2, f)(g)), 'function');
      assert.equal(_.curry(2, f)(g)(1), 2);
    });

    it('invoking with the correct number of arguments invokes the underlying operation', function () {
      assert.equal(_.curry(2, f)(g, 1), 2);
    });

    it('invoking with more arguments passes the remaining arguments to the result of the operation', function () {
      assert.equal(_.curry(2, f)(h, g, 1), 3);
    });

    property('should support any kind of arguments grouping', 'nat & nat & nat & nat', function (_ref) {
      var _ref2 = _slicedToArray(_ref, 4);

      var a = _ref2[0];
      var b = _ref2[1];
      var c = _ref2[2];
      var d = _ref2[3];

      return eqPairs(_.curry(4, i)(a)(b)(c)(d), _.curry(4, i)(a, b, c, d), _.curry(4, i)(a, b, c)(d), _.curry(4, i)(a, b)(c, d), _.curry(4, i)(a)(b, c, d), _.curry(4, i)(a)(b, c)(d), _.curry(4, i)(a, b)(c)(d), _.curry(4, i)(a)(b)(c, d), a + b + c + d);
    });
  });
});