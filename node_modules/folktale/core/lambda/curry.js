"use strict";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Transforms functions on tuples into curried functions.
 *
 * ## Why?
 *
 * Sometimes you want to specify part of the arguments of a function, and
 * leave the other arguments to be specified later. For this you could use
 * an arrow function:
 *
 *     const property = (key, object) => object[key]
 *     people.map(person => property('name', person));
 *
 * Currying allows you to construct functions that support partial application
 * naturally:
 *
 *     const property = curry(2, (key, object) => object[key]);
 *     people.map(property('name'))
 *
 * In essence, currying transforms a function that takes N arguments into
 * N functions that each take 1 argument. In the example above we'd have:
 *
 *     const property = (key, object) => object[key]
 *     curry(2, property)
 *     // => (key) => (object) => object[key]
 *
 *
 * ## Particularities of Folktale's `curry`
 *
 * Because JavaScript is a language where everything is variadic,
 * currying doesn't always fit. To try reducing the problems and
 * work with common JS idioms, currying functions *auto-unroll*
 * application. That is, something like:
 *
 *     const sum = curry(2, (x, y) => x + y)
 *     sum(1, 2, 3)
 *
 * Is handled as:
 *
 *     sum(1, 2)(3)
 *
 * This ensures that curried functions can be properly composed,
 * regardless of how you invoke them. But it also means that
 * passing more arguments to a function than the number of arguments
 * the whole composition takes will probably break your program.
 *
 * --------------------------------------------------------------------
 * name        : curry
 * module      : folktale/core/lambda/curry
 * copyright   : (c) 2015-2016 Quildreen Motta, and CONTRIBUTORS
 * licence     : MIT
 * repository  : https://github.com/origamitower/folktale
 *
 * category    : Currying
 * stability   : stable
 * portability : portable
 * platforms:
 *   - ECMAScript 3
 *
 * maintainers:
 *   - Quildreen Motta <queen@robotlolita.me>
 *
 * authors:
 *   - Quildreen Motta
 *
 * seeAlso:
 *   - type: link
 *     title: Why Curry Helps
 *     url: https://hughfdjackson.com/javascript/why-curry-helps/
 *
 *   - type: link
 *     title: Does Curry Help?
 *     url: https://hughfdjackson.com/javascript/does-curry-help/
 *
 * signature: curry(arity, fn)
 * type: |
 *   (Number, (Any...) => 'a) => Any... => 'a or ((Any...) => 'a)
 */
var curry = function curry(arity, fn) {
  // A curried function; accepts arguments until the number of given
  // arguments is greater or equal to the function's arity.
  var curried = function curried(oldArgs) {
    return function () {
      for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
        newArgs[_key] = arguments[_key];
      }

      var allArgs = oldArgs.concat(newArgs);
      var argCount = allArgs.length;

      return argCount < arity ? curried(allArgs) : argCount === arity ? fn.apply(undefined, _toConsumableArray(allArgs)) : /* otherwise */unrollInvoke(fn, arity, allArgs);
    };
  };

  // When a curried function receives more arguments than the number
  // of arguments it expects, we need to deal with the overflow.
  // The unrolled invocation takes care of this by passing the
  // remaining arguments to the resulting function.
  // This is required for proper composition of curried functions,
  // but fails with the composition of curried and non-curried
  // functions â€” this library always considers JS functions
  // not generated by *this* function as functions taking an
  // infinite number of arguments.
  var unrollInvoke = function unrollInvoke(fn_, arity_, args) {
    var firstFnArgs = args.slice(0, arity_);
    var secondFnArgs = args.slice(arity_);

    return fn_.apply(undefined, _toConsumableArray(firstFnArgs)).apply(undefined, _toConsumableArray(secondFnArgs));
  };

  return curried([]);
};

curry[Symbol.for("@@meta:magical")] = {
  "name": "curry",
  "module": "folktale/core/lambda/curry",
  "copyright": "(c) 2015-2016 Quildreen Motta, and CONTRIBUTORS",
  "licence": "MIT",
  "repository": "https://github.com/origamitower/folktale",
  "category": "Currying",
  "stability": "stable",
  "portability": "portable",
  "platforms": ["ECMAScript 3"],
  "maintainers": ["Quildreen Motta <queen@robotlolita.me>"],
  "authors": ["Quildreen Motta"],
  "seeAlso": [{
    "type": "link",
    "title": "Why Curry Helps",
    "url": "https://hughfdjackson.com/javascript/why-curry-helps/"
  }, {
    "type": "link",
    "title": "Does Curry Help?",
    "url": "https://hughfdjackson.com/javascript/does-curry-help/"
  }],
  "signature": "curry(arity, fn)",
  "type": "(Number, (Any...) => 'a) => Any... => 'a or ((Any...) => 'a)\n",
  "documentation": "\nTransforms functions on tuples into curried functions.\n\n## Why?\n\nSometimes you want to specify part of the arguments of a function, and\nleave the other arguments to be specified later. For this you could use\nan arrow function:\n\n    const property = (key, object) => object[key]\n    people.map(person => property('name', person));\n\nCurrying allows you to construct functions that support partial application\nnaturally:\n\n    const property = curry(2, (key, object) => object[key]);\n    people.map(property('name'))\n\nIn essence, currying transforms a function that takes N arguments into\nN functions that each take 1 argument. In the example above we'd have:\n\n    const property = (key, object) => object[key]\n    curry(2, property)\n    // => (key) => (object) => object[key]\n\n\n## Particularities of Folktale's `curry`\n\nBecause JavaScript is a language where everything is variadic,\ncurrying doesn't always fit. To try reducing the problems and\nwork with common JS idioms, currying functions *auto-unroll*\napplication. That is, something like:\n\n    const sum = curry(2, (x, y) => x + y)\n    sum(1, 2, 3)\n\nIs handled as:\n\n    sum(1, 2)(3)\n\nThis ensures that curried functions can be properly composed,\nregardless of how you invoke them. But it also means that\npassing more arguments to a function than the number of arguments\nthe whole composition takes will probably break your program.\n"
};
module.exports = curry;