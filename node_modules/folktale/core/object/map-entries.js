"use strict";

var _overwrite, _unique;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var hasOwnProperty = Object.prototype.hasOwnProperty;

/*~
 * Transforms pairs of (key, value) own properties in a plain object.
 *
 * The transformation takes a [key, value] pair, and is expected to return
 * a new [key, value] pair. The resulting object has not only its values
 * transformed, but also its keys:
 *
 *     const pair = { x: 10, y: 20 };
 *     mapEntries(
 *       pair,
 *       ([k, v]) => [k.toUpperCase(), v * 2],
 *       (r, k, v) => Object.assign(r, { [k]: v })
 *     );
 *     // => { X: 20, Y: 40 }
 *
 * > **NOTE**  
 * > The function expects you to provide a definition function, which will
 * > determine how to handle the mapping of the returned pairs. This is
 * > necessary because no single behaviour is always the right one for
 * > this. Common behaviours, such as `overwrite` older properties,
 * > and enforcing `unique` properties are provided as specialised
 * > frorms of this function.
 *
 *
 * > **NOTE**  
 * > The definition function may mutate the object.
 *
 *
 * > **WARNING**  
 * > [[mapEntries]] will not preserve the shape of the original object.
 * > It treats objects as plain maps from String to some value. It ignores
 * > things like prototypical delegation, symbols, and non-enumerable
 * > properties.
 *
 * ---------------------------------------------------------------------
 * name        : mapEntries
 * module      : folktale/core/object
 * copyright   : (c) 2015-2016 Quildreen Motta, and CONTRIBUTORS
 * licence     : MIT
 * repository  : https://github.com/origamitower/folktale
 *
 * category    : Transforming
 * stability   : stable
 * portability : portable
 * platforms:
 *   - ECMAScript 5
 *   - ECMAScript 3, with es5-shim
 *
 * maintainers:
 *   - Quildreen Motta <queen@robotlolita.me>
 *
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the number of own enumerable properties
 * signature  : mapEntries(object, transform, define)
 * type: |
 *   (
 *     object    : Object 'a,
 *     transform : ((String, 'a)) => (String, 'b),
 *     define    : (('x : Object 'b), String, 'b) => Object 'b :: mutates 'x
 *   ) => Object 'b
 */
var mapEntries = function mapEntries(object, transform, define) {
  return Object.keys(object).reduce(function (result, key) {
    var _transform = transform([key, object[key]]);

    var _transform2 = _slicedToArray(_transform, 2);

    var newKey = _transform2[0];
    var newValue = _transform2[1];

    return define(result, newKey, newValue);
  }, {});
};

/*~
 * Transforms pairs of (key, value) own properties in a plain object.
 *
 * This function is a specialised form of [[mapEntries]] that overwrites
 * duplicated keys when a collision happens. Because of this, the result
 * of a transformation where keys collide is not defined in ECMAScript 5
 * and older, but in ECMAScript 2015 properties that were inserted later
 * will win over properties that were inserted earlier.
 *
 * ---------------------------------------------------------------------
 * name      : overwrite
 * category  : Transforming
 * stability : stable
 *
 * seeAlso:
 *   - type: entity
 *     path: folktale/core/object/map-entries .unique
 *     reason: Consistently throws when a collision happens.
 *
 * complexity : O(n), n is the number of own enumerable properties
 * signature  : overwrite(object, transform)
 * type: |
 *   (Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b
 */
mapEntries[Symbol.for("@@meta:magical")] = {
  "name": "mapEntries",
  "module": "folktale/core/object",
  "copyright": "(c) 2015-2016 Quildreen Motta, and CONTRIBUTORS",
  "licence": "MIT",
  "repository": "https://github.com/origamitower/folktale",
  "category": "Transforming",
  "stability": "stable",
  "portability": "portable",
  "platforms": ["ECMAScript 5", "ECMAScript 3, with es5-shim"],
  "maintainers": ["Quildreen Motta <queen@robotlolita.me>"],
  "authors": ["Quildreen Motta"],
  "complexity": "O(n), n is the number of own enumerable properties",
  "signature": "mapEntries(object, transform, define)",
  "type": "(\n  object    : Object 'a,\n  transform : ((String, 'a)) => (String, 'b),\n  define    : (('x : Object 'b), String, 'b) => Object 'b :: mutates 'x\n) => Object 'b\n",
  "documentation": "\nTransforms pairs of (key, value) own properties in a plain object.\n\nThe transformation takes a [key, value] pair, and is expected to return\na new [key, value] pair. The resulting object has not only its values\ntransformed, but also its keys:\n\n    const pair = { x: 10, y: 20 };\n    mapEntries(\n      pair,\n      ([k, v]) => [k.toUpperCase(), v * 2],\n      (r, k, v) => Object.assign(r, { [k]: v })\n    );\n    // => { X: 20, Y: 40 }\n\n> **NOTE**  \n> The function expects you to provide a definition function, which will\n> determine how to handle the mapping of the returned pairs. This is\n> necessary because no single behaviour is always the right one for\n> this. Common behaviours, such as `overwrite` older properties,\n> and enforcing `unique` properties are provided as specialised\n> frorms of this function.\n\n\n> **NOTE**  \n> The definition function may mutate the object.\n\n\n> **WARNING**  \n> [[mapEntries]] will not preserve the shape of the original object.\n> It treats objects as plain maps from String to some value. It ignores\n> things like prototypical delegation, symbols, and non-enumerable\n> properties.\n"
};
mapEntries.overwrite = (_overwrite = function _overwrite(object, transform) {
  return mapEntries(object, transform, function (result, key, value) {
    result[key] = value;
    return result;
  });
}, _overwrite[Symbol.for("@@meta:magical")] = {
  "name": "overwrite",
  "category": "Transforming",
  "stability": "stable",
  "seeAlso": [{
    "type": "entity",
    "path": "folktale/core/object/map-entries .unique",
    "reason": "Consistently throws when a collision happens."
  }],
  "complexity": "O(n), n is the number of own enumerable properties",
  "signature": "overwrite(object, transform)",
  "type": "(Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b\n",
  "documentation": "\nTransforms pairs of (key, value) own properties in a plain object.\n\nThis function is a specialised form of [[mapEntries]] that overwrites\nduplicated keys when a collision happens. Because of this, the result\nof a transformation where keys collide is not defined in ECMAScript 5\nand older, but in ECMAScript 2015 properties that were inserted later\nwill win over properties that were inserted earlier.\n"
}, _overwrite);

/*~
 * Transforms pairs of (key, value) own properties in a plain object.
 *
 * This function is a specialised form of [[mapEntries]] that throws
 * when a key collision happens. Throwing makes this function potentially
 * unsafe to use, however it guarantees a consistent behaviour across
 * different ECMAScript versions and VMs.
 *
 * ---------------------------------------------------------------------
 * name      : unique
 * category  : Transforming
 * stability : stable
 *
 * seeAlso:
 *   - type: entity
 *     path: folktale/core/object/map-entries .overwrite
 *     reason: Overwrite keys when a collision happens.
 *
 * throws:
 *   Error: when the transform returns duplicate property names.
 *
 * complexity : O(n), n is the number of own enumerable properties
 * signature  : unique(object, transform)
 * type: |
 *   (Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b :: throws Error
 */
mapEntries.unique = (_unique = function _unique(object, transform) {
  return mapEntries(object, transform, function (result, key, value) {
    if (hasOwnProperty.call(result, key)) {
      throw new Error("The property " + key + " already exists in the resulting object.");
    }
    result[key] = value;
    return result;
  });
}, _unique[Symbol.for("@@meta:magical")] = {
  "name": "unique",
  "category": "Transforming",
  "stability": "stable",
  "seeAlso": [{
    "type": "entity",
    "path": "folktale/core/object/map-entries .overwrite",
    "reason": "Overwrite keys when a collision happens."
  }],
  "throws": {
    "Error": "when the transform returns duplicate property names."
  },
  "complexity": "O(n), n is the number of own enumerable properties",
  "signature": "unique(object, transform)",
  "type": "(Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b :: throws Error\n",
  "documentation": "\nTransforms pairs of (key, value) own properties in a plain object.\n\nThis function is a specialised form of [[mapEntries]] that throws\nwhen a key collision happens. Throwing makes this function potentially\nunsafe to use, however it guarantees a consistent behaviour across\ndifferent ECMAScript versions and VMs.\n"
}, _unique);

module.exports = mapEntries;