'use strict';

var _derive,
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message);
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message);if (left.length < expectedLength) {
      assert.ok(false, message);
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message);
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message);
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message) : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message);
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// -- CONSTANTS AND ALIASES --------------------------------------------
var TYPE = Symbol.for('@@folktale:adt:type');
var TAG = Symbol.for('@@folktale:adt:tag');
var keys = Object.keys;

// -- HELPERS ----------------------------------------------------------
function values(object) {
  return keys(object).map(function (key) {
    return object[key];
  });
}

function mapObject(object, transform) {
  return keys(object).reduce(function (result, key) {
    result[key] = transform(key, object[key]);
    return result;
  }, {});
}

function defineVariants(typeId, patterns, adt) {
  return mapObject(patterns, function (name, constructor) {
    var _cata, _Object$assign, _hasInstance;

    function InternalConstructor() {}
    InternalConstructor.prototype = Object.create(adt);

    Object.assign(InternalConstructor.prototype, (_Object$assign = {}, _defineProperty(_Object$assign, 'is' + name, true), _defineProperty(_Object$assign, TAG, name), _defineProperty(_Object$assign, 'constructor', constructor), _defineProperty(_Object$assign, 'cata', (_cata = function cata(pattern) {
      return pattern[name](this);
    }, _cata[Symbol.for('@@meta:magical')] = {
      'name': 'cata',
      'signature': '.cata(pattern)',
      'stability': 'experimental',
      'category': 'Extracting Information',
      'type': '(\'a is Variant).({ \'b: (Object Any) => \'c }) => \'c\nwhere \'b = \'a[`@@folktale:adt:tag]\n',
      '~belongsTo': 'constructor',
      'documentation': '\nSelects an operation based on this Variant\'s tag.\n\nThe `cata`morphism operation allows a very limited form of\npattern matching, by selecting an operation depending on this\nvalue\'s tag.\n'
    }, _cata)), _Object$assign));

    function makeInstance() {
      var result = new InternalConstructor();
      Object.assign(result, constructor.apply(undefined, arguments));
      return result;
    }

    Object.assign(makeInstance, {
      tag: name,
      type: typeId,
      constructor: constructor,
      prototype: InternalConstructor.prototype,

      /*~
       * Checks if a value belongs to this Variant.
       *
       * This is similar to the ADT.hasInstance check, with the
       * exception that we also check if the value is of the same
       * variant (has the same tag) as this variant.
       *
       * ---
       * name      : hasInstance
       * signature : hasInstance(value)
       * category  : Comparing and Testing
       * type: |
       *   (Variant) => Boolean
       *
       * ~belongsTo: constructor
       */
      hasInstance: (_hasInstance = function hasInstance(value) {
        return adt.hasInstance(value) && value[TAG] === name;
      }, _hasInstance[Symbol.for('@@meta:magical')] = {
        'name': 'hasInstance',
        'signature': 'hasInstance(value)',
        'category': 'Comparing and Testing',
        'type': '(Variant) => Boolean\n',
        '~belongsTo': 'constructor',
        'documentation': '\nChecks if a value belongs to this Variant.\n\nThis is similar to the ADT.hasInstance check, with the\nexception that we also check if the value is of the same\nvariant (has the same tag) as this variant.\n'
      }, _hasInstance)
    });

    return makeInstance;
  });
}

// -- IMPLEMENTATION ---------------------------------------------------

/*~
 * Constructs a union data structure.
 *
 * ## Using the ADT module::
 *
 *     const List = data('List', {
 *       Nil(){ },
 *       Cons(value, rest) {
 *         return { value, rest };
 *       }
 *     });
 *
 *     const { Nil, Cons } = List;
 *
 *     Cons('a', Cons('b', Cons('c', Nil())));
 *     // ==> { value: 'a', rest: { value: 'b', ..._ }}
 *
 *
 * ## Why?
 *
 * JavaScript, like most languages, doesn't have a good support for modelling
 * choices as data structures out of the box. In JavaScript, it's easy to model
 * things that are a composition of several independent pieces of data, but it's
 * hard to model things where the information they represent vary depending on
 * its "type".
 *
 * For correctly modelling something, we usually want to have both record
 * (the composition of independent pieces of data) and union (a choice between
 * one of many possibilities) types. This module provides the missing *union type*
 * support for JavaScript.
 *
 *
 * ## Architecture
 *
 * The ADT module approaches this problem in a structural-type-ish way, which
 * happens to be very similar to how OCaml's polymorphic variants work, and
 * how different values are handled in untyped languages.
 *
 * In essence, calling `data` with a set of patterns results in the creation
 * of N constructors, each with a distinct **tag**.
 *
 * Revisiting the previous `List` ADT example, when one writes:
 *
 *     const List = data('List', {
 *       Nil:  () => {},
 *       Cons: (value, rest) => ({ value, rest })
 *     })
 *
 * That's roughly equivalent to the idiomatic:
 *
 *     const List = {};
 *
 *     function Nil() { }
 *     Nil.prototype = Object.create(List);
 *
 *     function Cons(value, rest) {
 *       this.value = value;
 *       this.rest  = rest;
 *     }
 *     Cons.prototype = Object.create(List);
 *
 * The `data` function takes as arguments a type identifier (which can be any
 * object, if you want it to be unique), and an object with the variants. Each
 * property in this object is expected to be a function that returns the
 * properties that'll be provided for the instance of that variant.
 *
 * The given variants are not returned directly. Instead, we return a wrapper
 * that will construct a proper value of this type, and augment it with the
 * properties provided by that variant initialiser.
 *
 *
 * ## Reflection
 *
 * The ADT module relies on JavaScript's built-in reflective features first,
 * and adds a couple of additional fields to this.
 *
 *
 * ### Types and Tags
 *
 * The provided type for the ADT, and the tag provided for the variant
 * are both reified in the ADT structure and the constructed values. These
 * allow checking the compatibility of different values structurally, which
 * sidesteps the problems with realms.
 *
 * The type of the ADT is provided by the global symbol `@@folktale:adt:type`::
 *
 *     const Id = data('Identity', { Id: () => {} });
 *     Id[Symbol.for('@@folktale:adt:type')]
 *     // ==> 'Identity'
 *
 * The tag of the value is provided by the global symbol `@@folktale:adt:tag`::
 *
 *     const List = data('List', {
 *       Nil: () => {},
 *       Cons: (h, t) => ({ h, t })
 *     });
 *     List.Nil()[Symbol.for('@@folktale:adt:tag')]
 *     // ==> 'Nil'
 *
 * These symbols are also exported as properties of the `data` function
 * itself, so you can use `data.typeSymbol` and `data.tagSymbol` instead
 * of retrieving a symbol instance with the `Symbol.for` function.
 *
 *
 * ### `is-a` tests
 *
 * Sometimes it's desirable to test if a value belongs to an ADT or
 * to a variant. Out of the box, the structures constructed by ADT
 * provide a `hasInstance` check that verify if a value is structurally
 * part of an ADT structure, by checking the Type and Tag of that value.
 *
 * ###### checking if a value belongs to an ADT::
 *
 *     const IdA = data('IdA', { Id: (x) => ({ x }) });
 *     const IdB = data('IdB', { Id: (x) => ({ x }) });
 *
 *     IdA.hasInstance(IdA.Id(1))  // ==> true
 *     IdA.hasInstance(IdB.Id(1))  // ==> false
 *
 *
 * ###### checking if a value belongs to a variant::
 *
 *     const Either = data('Either', {
 *       Left:  value => ({ value }),
 *       Right: value => ({ value })
 *     });
 *     const { Left, Right } = Either;
 *
 *     Left.hasInstance(Left(1));  // ==> true
 *     Left.hasInstance(Right(1)); // ==> false
 *
 *
 * Note that if two ADTs have the same type ID, they'll be considered
 * equivalent by `hasInstance`. You may pass an object (like
 * `Symbol('type name')`) to `data` to avoid this, however reference
 * equality does not work across realms in JavaScript.
 *
 * Since all instances inherit from the ADT and the variant's prototype
 * it's also possible to use `proto.isPrototypeOf(instance)` to check
 * if an instance belongs to an ADT by reference equality, rather than
 * structural equality.
 *
 *
 * ## Extending ADTs
 *
 * Because all variants inherit from the ADT namespace, it's possible
 * to provide new functionality to all variants by simply adding new
 * properties to the ADT::
 *
 *     const List = data('List', {
 *       Nil:  () => {},
 *       Cons: (value, rest) => ({ value, rest })
 *     });
 *
 *     const { Nil, Cons } = List;
 *
 *     List.sum = function() {
 *       return this.cata({
 *         Nil:  () => 0,
 *         Cons: ({ value, rest }) => value + rest.sum()
 *       });
 *     };
 *
 *     Cons(1, Cons(2, Nil())).sum();
 *     // ==> 3
 *
 * A better approach, however, may be to use the `derive` function from
 * the ADT to provide new functionality to every variant. `derive` accepts
 * many derivation functions, which are just functions taking a variant and
 * and ADT, and providing new functionality for that variant.
 *
 * If one wanted to define a JSON serialisation for each variant, for example,
 * they could do so by using the `derive` functionality::
 *
 *     function ToJSON(variant, adt) {
 *       const { tag, type } = variant;
 *       variant.prototype.toJSON = function() {
 *         const json = { tag: `${type}:${tag}` };
 *         Object.keys(this).forEach(key => {
 *           const value = this[key];
 *           if (value && typeof value.toJSON === "function") {
 *             json[key] = value.toJSON();
 *           } else {
 *             json[key] = value;
 *           }
 *         });
 *         return json;
 *       }
 *     }
 *
 *     const List = data('List', {
 *       Nil:  () => {},
 *       Cons: (value, rest) => ({ value, rest })
 *     }).derive(ToJSON);
 *
 *     const { Nil, Cons } = List;
 *
 *     Nil().toJSON()
 *     // ==> { tag: "List:Nil" }
 *
 *     Cons(1, Nil()).toJSON()
 *     // ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}
 *
 *
 *
 * ---------------------------------------------------------------------
 * name        : data
 * module      : folktale/core/adt/core
 * copyright   : (c) 2015-2016 Quildreen Motta, and CONTRIBUTORS
 * licence     : MIT
 * repository  : https://github.com/origamitower/folktale
 *
 * category    : Data Structures
 * stability   : experimental
 * portability : portable
 * platforms:
 *   - ECMAScript 2015
 *   - ECMAScript 5, with es6-shim
 *   - ECMAScript 3, with es5-shim and es6-shim
 *
 * maintainers:
 *   - Quildreen Motta <queen@robotlolita.me>
 *
 * authors:
 *   - Quildreen Motta
 *
 * seeAlso:
 *   - type  : link
 *     title : "Designing with types: Making illegal states unrepresentable"
 *     url   : http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/
 *
 * signature: data(typeId, patterns)
 * type: |
 *   (String, Object (Array String)) => ADT
 */
var data = function data(typeId, patterns) {
  var _variants, _hasInstance2, _Object$assign2;

  var ADTNamespace = Object.create(ADT);
  var variants = defineVariants(typeId, patterns, ADTNamespace);

  Object.assign(ADTNamespace, variants, (_Object$assign2 = {}, _defineProperty(_Object$assign2, TYPE, typeId), _defineProperty(_Object$assign2, 'variants', (_variants = values(variants), _variants[Symbol.for('@@meta:magical')] = {
    'name': 'variants',
    'type': 'Array Variant',
    '~belongsTo': 'ADTNamespace',
    'documentation': '\nThe variants present in this ADT.'
  }, _variants)), _defineProperty(_Object$assign2, 'hasInstance', (_hasInstance2 = function hasInstance(value) {
    return value[TYPE] === this[TYPE];
  }, _hasInstance2[Symbol.for('@@meta:magical')] = {
    'name': 'hasInstance',
    'category': 'Comparing and Testing',
    'signature': '.hasInstance(value)',
    'type': 'ADT.(Variant) -> Boolean\n',
    '~belongsTo': 'ADTNamespace',
    'documentation': '\nChecks if a value belongs to this ADT.\n\nValues are considered to belong to an ADT if they have the same\n`Symbol.for(\'@@folktale:adt:type\')` property as the ADT\'s.\n\nIf you don\'t want a structural check, you can test whether the\nADT is in the prototype chain of the value, but keep in mind that\nthis does not work cross-realm.\n'
  }, _hasInstance2)), _Object$assign2));

  return ADTNamespace;
};

/*~
 * The basis of all algebraic data types.
 *
 * ADT is used basically to share some methods for refining data structures
 * created by this module, derivation being one of them.
 *
 * ---------------------------------------------------------------------
 * name       : ADT
 * category   : Data Structures
 * ~belongsTo : data
 */
data[Symbol.for('@@meta:magical')] = {
  'name': 'data',
  'module': 'folktale/core/adt/core',
  'copyright': '(c) 2015-2016 Quildreen Motta, and CONTRIBUTORS',
  'licence': 'MIT',
  'repository': 'https://github.com/origamitower/folktale',
  'category': 'Data Structures',
  'stability': 'experimental',
  'portability': 'portable',
  'platforms': ['ECMAScript 2015', 'ECMAScript 5, with es6-shim', 'ECMAScript 3, with es5-shim and es6-shim'],
  'maintainers': ['Quildreen Motta <queen@robotlolita.me>'],
  'authors': ['Quildreen Motta'],
  'seeAlso': [{
    'type': 'link',
    'title': 'Designing with types: Making illegal states unrepresentable',
    'url': 'http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/'
  }],
  'signature': 'data(typeId, patterns)',
  'type': '(String, Object (Array String)) => ADT\n',
  'documentation': '\nConstructs a union data structure.\n\n## Using the ADT module:\n\n    const List = data(\'List\', {\n      Nil(){ },\n      Cons(value, rest) {\n        return { value, rest };\n      }\n    });\n\n    const { Nil, Cons } = List;\n\n    Cons(\'a\', Cons(\'b\', Cons(\'c\', Nil())));\n    // ==> { value: \'a\', rest: { value: \'b\', ..._ }}\n\n\n## Why?\n\nJavaScript, like most languages, doesn\'t have a good support for modelling\nchoices as data structures out of the box. In JavaScript, it\'s easy to model\nthings that are a composition of several independent pieces of data, but it\'s\nhard to model things where the information they represent vary depending on\nits "type".\n\nFor correctly modelling something, we usually want to have both record\n(the composition of independent pieces of data) and union (a choice between\none of many possibilities) types. This module provides the missing *union type*\nsupport for JavaScript.\n\n\n## Architecture\n\nThe ADT module approaches this problem in a structural-type-ish way, which\nhappens to be very similar to how OCaml\'s polymorphic variants work, and\nhow different values are handled in untyped languages.\n\nIn essence, calling `data` with a set of patterns results in the creation\nof N constructors, each with a distinct **tag**.\n\nRevisiting the previous `List` ADT example, when one writes:\n\n    const List = data(\'List\', {\n      Nil:  () => {},\n      Cons: (value, rest) => ({ value, rest })\n    })\n\nThat\'s roughly equivalent to the idiomatic:\n\n    const List = {};\n\n    function Nil() { }\n    Nil.prototype = Object.create(List);\n\n    function Cons(value, rest) {\n      this.value = value;\n      this.rest  = rest;\n    }\n    Cons.prototype = Object.create(List);\n\nThe `data` function takes as arguments a type identifier (which can be any\nobject, if you want it to be unique), and an object with the variants. Each\nproperty in this object is expected to be a function that returns the\nproperties that\'ll be provided for the instance of that variant.\n\nThe given variants are not returned directly. Instead, we return a wrapper\nthat will construct a proper value of this type, and augment it with the\nproperties provided by that variant initialiser.\n\n\n## Reflection\n\nThe ADT module relies on JavaScript\'s built-in reflective features first,\nand adds a couple of additional fields to this.\n\n\n### Types and Tags\n\nThe provided type for the ADT, and the tag provided for the variant\nare both reified in the ADT structure and the constructed values. These\nallow checking the compatibility of different values structurally, which\nsidesteps the problems with realms.\n\nThe type of the ADT is provided by the global symbol `@@folktale:adt:type`:\n\n    const Id = data(\'Identity\', { Id: () => {} });\n    Id[Symbol.for(\'@@folktale:adt:type\')]\n    // ==> \'Identity\'\n\nThe tag of the value is provided by the global symbol `@@folktale:adt:tag`:\n\n    const List = data(\'List\', {\n      Nil: () => {},\n      Cons: (h, t) => ({ h, t })\n    });\n    List.Nil()[Symbol.for(\'@@folktale:adt:tag\')]\n    // ==> \'Nil\'\n\nThese symbols are also exported as properties of the `data` function\nitself, so you can use `data.typeSymbol` and `data.tagSymbol` instead\nof retrieving a symbol instance with the `Symbol.for` function.\n\n\n### `is-a` tests\n\nSometimes it\'s desirable to test if a value belongs to an ADT or\nto a variant. Out of the box, the structures constructed by ADT\nprovide a `hasInstance` check that verify if a value is structurally\npart of an ADT structure, by checking the Type and Tag of that value.\n\n###### checking if a value belongs to an ADT:\n\n    const IdA = data(\'IdA\', { Id: (x) => ({ x }) });\n    const IdB = data(\'IdB\', { Id: (x) => ({ x }) });\n\n    IdA.hasInstance(IdA.Id(1))  // ==> true\n    IdA.hasInstance(IdB.Id(1))  // ==> false\n\n\n###### checking if a value belongs to a variant:\n\n    const Either = data(\'Either\', {\n      Left:  value => ({ value }),\n      Right: value => ({ value })\n    });\n    const { Left, Right } = Either;\n\n    Left.hasInstance(Left(1));  // ==> true\n    Left.hasInstance(Right(1)); // ==> false\n\n\nNote that if two ADTs have the same type ID, they\'ll be considered\nequivalent by `hasInstance`. You may pass an object (like\n`Symbol(\'type name\')`) to `data` to avoid this, however reference\nequality does not work across realms in JavaScript.\n\nSince all instances inherit from the ADT and the variant\'s prototype\nit\'s also possible to use `proto.isPrototypeOf(instance)` to check\nif an instance belongs to an ADT by reference equality, rather than\nstructural equality.\n\n\n## Extending ADTs\n\nBecause all variants inherit from the ADT namespace, it\'s possible\nto provide new functionality to all variants by simply adding new\nproperties to the ADT:\n\n    const List = data(\'List\', {\n      Nil:  () => {},\n      Cons: (value, rest) => ({ value, rest })\n    });\n\n    const { Nil, Cons } = List;\n\n    List.sum = function() {\n      return this.cata({\n        Nil:  () => 0,\n        Cons: ({ value, rest }) => value + rest.sum()\n      });\n    };\n\n    Cons(1, Cons(2, Nil())).sum();\n    // ==> 3\n\nA better approach, however, may be to use the `derive` function from\nthe ADT to provide new functionality to every variant. `derive` accepts\nmany derivation functions, which are just functions taking a variant and\nand ADT, and providing new functionality for that variant.\n\nIf one wanted to define a JSON serialisation for each variant, for example,\nthey could do so by using the `derive` functionality:\n\n    function ToJSON(variant, adt) {\n      const { tag, type } = variant;\n      variant.prototype.toJSON = function() {\n        const json = { tag: `${type}:${tag}` };\n        Object.keys(this).forEach(key => {\n          const value = this[key];\n          if (value && typeof value.toJSON === "function") {\n            json[key] = value.toJSON();\n          } else {\n            json[key] = value;\n          }\n        });\n        return json;\n      }\n    }\n\n    const List = data(\'List\', {\n      Nil:  () => {},\n      Cons: (value, rest) => ({ value, rest })\n    }).derive(ToJSON);\n\n    const { Nil, Cons } = List;\n\n    Nil().toJSON()\n    // ==> { tag: "List:Nil" }\n\n    Cons(1, Nil()).toJSON()\n    // ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}\n\n\n',
  'examples': [{
    'name': 'Using the ADT module',
    'call': function call() {
      var _rest;

      var List = data('List', {
        Nil: function Nil() {},
        Cons: function Cons(value, rest) {
          return { value: value, rest: rest };
        }
      });var Nil = List.Nil;
      var Cons = List.Cons;
      __metamagical_assert_equals(require('assert'), Cons('a', Cons('b', Cons('c', Nil()))), _defineProperty({ value: 'a', rest: (_rest = { value: 'b' }, _defineProperty(_rest, Symbol.for('@@meta:magical:assertion-rest'), true), _defineProperty(_rest, Symbol.for('@@meta:magical:assertion-type'), 'record'), _rest) }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Cons(\'a\', Cons(\'b\', Cons(\'c\', Nil()))) ==> { value: \'a\', rest: { value: \'b\', ..._ }}');; // ==> { value: 'a', rest: { value: 'b', ..._ }}
    }
  }, function () {
    var Id = data('Identity', { Id: function Id() {} });__metamagical_assert_equals(require('assert'), Id[Symbol.for('@@folktale:adt:type')], 'Identity', 'Id[Symbol.for(\'@@folktale:adt:type\')] ==> \'Identity\'');; // ==> 'Identity'
  }, function () {
    var List = data('List', { Nil: function Nil() {}, Cons: function Cons(h, t) {
        return { h: h, t: t };
      } });__metamagical_assert_equals(require('assert'), List.Nil()[Symbol.for('@@folktale:adt:tag')], 'Nil', 'List.Nil()[Symbol.for(\'@@folktale:adt:tag\')] ==> \'Nil\'');; // ==> 'Nil'
  }, {
    'name': 'checking if a value belongs to an ADT',
    'call': function call() {
      var IdA = data('IdA', { Id: function Id(x) {
          return { x: x };
        } });var IdB = data('IdB', { Id: function Id(x) {
          return { x: x };
        } });__metamagical_assert_equals(require('assert'), IdA.hasInstance(IdA.Id(1)), true, 'IdA.hasInstance(IdA.Id(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), IdA.hasInstance(IdB.Id(1)), false, 'IdA.hasInstance(IdB.Id(1)) ==> false');; // ==> false
    }
  }, {
    'name': 'checking if a value belongs to a variant',
    'call': function call() {
      var Either = data('Either', { Left: function Left(value) {
          return { value: value };
        }, Right: function Right(value) {
          return { value: value };
        } });var Left = Either.Left;
      var Right = Either.Right;
      __metamagical_assert_equals(require('assert'), Left.hasInstance(Left(1)), true, 'Left.hasInstance(Left(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Left.hasInstance(Right(1)), false, 'Left.hasInstance(Right(1)) ==> false');; // ==> false
    }
  }, function () {
    var List = data('List', { Nil: function Nil() {}, Cons: function Cons(value, rest) {
        return { value: value, rest: rest };
      } });var Nil = List.Nil;
    var Cons = List.Cons;
    List.sum = function () {
      return this.cata({ Nil: function Nil() {
          return 0;
        }, Cons: function Cons(_ref) {
          var value = _ref.value;
          var rest = _ref.rest;
          return value + rest.sum();
        } });
    };__metamagical_assert_equals(require('assert'), Cons(1, Cons(2, Nil())).sum(), 3, 'Cons(1, Cons(2, Nil())).sum() ==> 3');; // ==> 3
  }, function () {
    function ToJSON(variant, adt) {
      var tag = variant.tag;
      var type = variant.type;
      variant.prototype.toJSON = function () {
        var _this2 = this;

        var json = { tag: type + ':' + tag };Object.keys(this).forEach(function (key) {
          var value = _this2[key];if (value && typeof value.toJSON === "function") {
            json[key] = value.toJSON();
          } else {
            json[key] = value;
          }
        });return json;
      };
    }var List = data('List', { Nil: function Nil() {}, Cons: function Cons(value, rest) {
        return { value: value, rest: rest };
      } }).derive(ToJSON);var Nil = List.Nil;
    var Cons = List.Cons;
    __metamagical_assert_equals(require('assert'), Nil().toJSON(), _defineProperty({ tag: "List:Nil" }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Nil().toJSON() ==> { tag: "List:Nil" }');; // ==> { tag: "List:Nil" }
    __metamagical_assert_equals(require('assert'), Cons(1, Nil()).toJSON(), _defineProperty({ tag: "List:Cons", value: 1, rest: _defineProperty({ "tag": "List:Nil" }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Cons(1, Nil()).toJSON() ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}');; // ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}
  }]
};
var ADT = {

  /*~
   * Allows a function to provide functionality to variants in an ADT.
   *
   * The `derive` method exists to support meta-programming on ADT objects,
   * such that additional functionality (implementation of interfaces or
   * protocols, for example) may be provided by libraries instead of having
   * to be hand-coded by the user.
   *
   * The operation accepts many `derivation` functions, which will be invoked
   * for each variant in the ADT, where a Variant is just an object with the
   * following attributes:
   *
   *     interface Variant(Any...) -> 'a <: self.prototype {
   *       tag         : String,
   *       type        : Any,
   *       constructor : Constructor,
   *       prototype   : Object
   *     }
   *
   * -------------------------------------------------------------------
   * name        : derive
   * category    : Refinement
   * stability   : experimental
   * portability : portable
   * platforms:
   *   - ECMAScript 5
   *   - ECMAScript 3, with es5-shim
   *
   * signature: .derive(...derivation)
   * type: |
   *   ADT . (...(Variant, ADT) => Any) => ADT
   */

  derive: (_derive = function derive() {
    var _this = this;

    for (var _len = arguments.length, derivations = Array(_len), _key = 0; _key < _len; _key++) {
      derivations[_key] = arguments[_key];
    }

    derivations.forEach(function (derivation) {
      _this.variants.forEach(function (variant) {
        return derivation(variant, _this);
      });
    });
    return this;
  }, _derive[Symbol.for('@@meta:magical')] = {
    'name': 'derive',
    'category': 'Refinement',
    'stability': 'experimental',
    'portability': 'portable',
    'platforms': ['ECMAScript 5', 'ECMAScript 3, with es5-shim'],
    'signature': '.derive(...derivation)',
    'type': 'ADT . (...(Variant, ADT) => Any) => ADT\n \n',
    'documentation': '\nAllows a function to provide functionality to variants in an ADT.\n\nThe `derive` method exists to support meta-programming on ADT objects,\nsuch that additional functionality (implementation of interfaces or\nprotocols, for example) may be provided by libraries instead of having\nto be hand-coded by the user.\n\nThe operation accepts many `derivation` functions, which will be invoked\nfor each variant in the ADT, where a Variant is just an object with the\nfollowing attributes:\n\n    interface Variant(Any...) -> \'a <: self.prototype {\n      tag         : String,\n      type        : Any,\n      constructor : Constructor,\n      prototype   : Object\n    }\n'
  }, _derive)
};

// -- Exports ----------------------------------------------------------
ADT[Symbol.for('@@meta:magical')] = {
  'name': 'ADT',
  'category': 'Data Structures',
  '~belongsTo': 'data',
  'documentation': '\nThe basis of all algebraic data types.\n\nADT is used basically to share some methods for refining data structures\ncreated by this module, derivation being one of them.\n'
};
data.ADT = ADT;
data.typeSymbol = TYPE;
data.tagSymbol = TAG;

module.exports = data;