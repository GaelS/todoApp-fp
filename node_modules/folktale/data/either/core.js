'use strict';

var assertType = require('../../helpers/assertType');

var _require = require('../../core/adt');

var data = _require.data;
var setoid = _require.setoid;

var fl = require('fantasy-land');

var Either = data('folktale:Data.Either', {
  Left: function Left(value) {
    return { value: value };
  },
  Right: function Right(value) {
    return { value: value };
  }
}).derive(setoid);

var _Left = Either.Left;
var _Right = Either.Right;


var assertFunction = function assertFunction(method, transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError(method + ' expects a function, but was given ' + transformation + '.');
  }
};

var assertEither = assertType(Either);

// -- Functor ----------------------------------------------------------
_Left.prototype[fl.map] = function (transformation) {
  assertFunction('Either.Left#map', transformation);
  return this;
};

_Right.prototype[fl.map] = function (transformation) {
  assertFunction('Either.Right#map', transformation);
  return _Right(transformation(this.value));
};

// -- Apply ------------------------------------------------------------
_Left.prototype[fl.ap] = function (anEither) {
  assertEither('Left#ap', anEither);
  return this;
};

_Right.prototype[fl.ap] = function (anEither) {
  assertEither('Right#ap', anEither);
  return anEither.map(this.value);
};

// -- Applicative ------------------------------------------------------
Either[fl.of] = _Right;

// -- Chain ------------------------------------------------------------
_Left.prototype[fl.chain] = function (transformation) {
  assertFunction('Either.Left#chain', transformation);
  return this;
};

_Right.prototype[fl.chain] = function (transformation) {
  assertFunction('Either.Right#chain', transformation);
  return transformation(this.value);
};

// -- Show -------------------------------------------------------------

// (for Object.prototype.toString)
Either[Symbol.toStringTag] = '(folktale) Either';
_Left.prototype[Symbol.toStringTag] = '(folktale) Either.Left';
_Right.prototype[Symbol.toStringTag] = '(folktale) Either.Right';

// (regular JavaScript representations)
Either.toString = function () {
  return '(folktale) Either';
};
_Left.prototype.toString = function () {
  return '(folktale) Either.Left(' + this.value + ')';
};

_Right.prototype.toString = function () {
  return '(folktale) Either.Right(' + this.value + ')';
};

// (Node REPL representations)
Either.inspect = Either.toString;
_Left.prototype.inspect = _Left.prototype.toString;
_Right.prototype.inspect = _Right.prototype.toString;

// -- Extracting values and recovering ---------------------------------

// NOTE:
// `get` is similar to Comonad's `extract`. The reason we don't implement
// Comonad here is that `get` is partial, and not defined for Nothing
// values.

_Left.prototype.get = function () {
  throw new TypeError('Can\'t extract the value of a Left.\n\nLeft does not contain a normal value - it contains an error.\nYou might consider switching from Either#get to Either#getOrElse, or some other method\nthat is not partial.\n  ');
};

_Right.prototype.get = function () {
  return this.value;
};

_Left.prototype.getOrElse = function (default_) {
  return default_;
};

_Right.prototype.getOrElse = function (_default_) {
  return this.value;
};

_Left.prototype.orElse = function (handler) {
  return handler(this.value);
};

_Right.prototype.orElse = function (_) {
  return this;
};

// -- Folds and extended transformations--------------------------------

Either.fold = function (f, g) {
  return this.cata({
    Left: function Left(_ref) {
      var value = _ref.value;
      return f(value);
    },
    Right: function Right(_ref2) {
      var value = _ref2.value;
      return g(value);
    }
  });
};

Either.merge = function () {
  return this.value;
};

Either.swap = function () {
  return this.fold(_Right, _Left);
};

Either.bimap = function (f, g) {
  return this.cata({
    Left: function Left(_ref3) {
      var value = _ref3.value;
      return _Left(f(value));
    },
    Right: function Right(_ref4) {
      var value = _ref4.value;
      return _Right(g(value));
    }
  });
};

_Left.prototype.leftMap = function (transformation) {
  assertFunction('Either.Left#leftMap', transformation);
  return _Left(transformation(this.value));
};

_Right.prototype.leftMap = function (transformation) {
  assertFunction('Either.Right#leftMap', transformation);
  return this;
};

// -- JSON conversions -------------------------------------------------
_Left.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Either.Left',
    value: this.value
  };
};

_Right.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Either.Right',
    value: this.value
  };
};

module.exports = Either;