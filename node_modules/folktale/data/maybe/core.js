'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../core/adt');

var data = _require.data;


var fl = require('fantasy-land');

var Maybe = data('folktale:Data.Maybe', {
  Nothing: function Nothing() {},
  Just: function Just(value) {
    return { value: value };
  }
});

var Nothing = Maybe.Nothing;
var Just = Maybe.Just;

// -- Assertions -------------------------------------------------------

var assertMaybe = function assertMaybe(method, value) {
  if (process.env.NODE_ENV !== 'production' && !(value instanceof Maybe)) {
    console.warn('\n' + method + ' expects a value of the same type, but was given ' + value + '.\n\nThis could mean that you\'ve provided the wrong value to the method, in\nwhich case this is a bug in your program, and you should try to track\ndown why the wrong value is getting here.\n\nBut this could also mean that you have more than one Maybe library\ninstantiated in your program. This is not **necessarily** a bug, it\ncould happen for several reasons:\n\n 1) You\'re loading the library in Node, and Node\'s cache didn\'t give\n    you back the same instance you had previously requested.\n\n 2) You have more than one Code Realm in your program, and objects\n    created from the same library, in different realms, are interacting.\n\n 3) You have a version conflict of folktale libraries, and objects\n    created from different versions of the library are interacting.\n\nIf your situation fits the cases (1) or (2), you are okay, as long as\nthe objects originate from the same version of the library. Folktale\ndoes not rely on reference checking, only structural checking. However\nyou\'ll want to watch out if you\'re modifying the Maybe\'s prototype,\nbecause you\'ll have more than one of them, and you\'ll want to make\nsure you do the same change in all of them — ideally you shouldn\'t\nbe modifying the object, though.\n\nIf your situation fits the case (3), you are *probably* okay if the\nversion difference isn\'t a major one. However, at this point the\nbehaviour of your program using Maybe is undefined, and you should\ntry looking into why the version conflict is happening.\n\nParametric modules can help ensuring your program only has a single\ninstance of the folktale library. Check out the Folktale Architecture\ndocumentation for more information.\n    ');
  }
};

// -- Setoid -----------------------------------------------------------
Nothing.prototype[fl.equals] = function (aMaybe) {
  assertMaybe('Maybe.Nothing#equals', aMaybe);
  return aMaybe.isNothing;
};

Just.prototype[fl.equals] = function (aMaybe) {
  assertMaybe('Maybe.Just#equals', aMaybe);
  return aMaybe.isJust && aMaybe.value === this.value;
};

// -- Functor ----------------------------------------------------------
Nothing.prototype[fl.map] = function (transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError('Maybe.Nothing#map expects a function, but was given ' + transformation + '.');
  }

  return this;
};

Just.prototype[fl.map] = function (transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError('Maybe.Just#map expects a function, but was given ' + transformation + '.');
  }

  return Just(transformation(this.value));
};

// -- Apply ------------------------------------------------------------
Nothing.prototype[fl.ap] = function (aMaybe) {
  assertMaybe('Maybe.Nothing#ap', aMaybe);
  return this;
};

Just.prototype[fl.ap] = function (aMaybe) {
  assertMaybe('Maybe.Just#ap', aMaybe);
  return aMaybe.map(this.value);
};

// -- Applicative ------------------------------------------------------
Maybe[fl.of] = Just;

// -- Chain ------------------------------------------------------------
Nothing.prototype[fl.chain] = function (transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError('Maybe.Nothing#chain expects a function, but was given ' + transformation + '.');
  }

  return this;
};

Just.prototype[fl.chain] = function (transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError('Maybe.Just#chain expects a function, but was given ' + transformation + '.');
  }

  return transformation(this.value);
};

// -- Show -------------------------------------------------------------

// (for Object.prototype.toString)
Maybe[Symbol.toStringTag] = '(folktale) Maybe';
Nothing.prototype[Symbol.toStringTag] = '(folktale) Maybe.Nothing';
Just.prototype[Symbol.toStringTag] = '(folktale) Maybe.Just';

// (regular JavaScript representations)
Maybe.toString = function () {
  return '(folktale) Maybe';
};
Nothing.prototype.toString = function () {
  return '(folktale) Maybe.Nothing()';
};

Just.prototype.toString = function () {
  return '(folktale) Maybe.Just(' + this.value + ')';
};

// (Node REPL representations)
Maybe.inspect = Maybe.toString;
Nothing.prototype.inspect = Maybe.Nothing.prototype.toString;
Just.prototype.inspect = Maybe.Just.prototype.toString;

// -- Extracting values and recovering ---------------------------------

// NOTE:
// `get` is similar to Comonad's `extract`. The reason we don't implement
// Comonad here is that `get` is partial, and not defined for Nothing
// values.

Nothing.prototype.get = function () {
  throw new TypeError('Can\'t extract the value of a Nothing.\n\nSince Nothing holds no values, it\'s not possible to extract one from them.\nYou might consider switching from Maybe#get to Maybe#getOrElse, or some other method\nthat is not partial.\n  ');
};

Just.prototype.get = function () {
  return this.value;
};

Nothing.prototype.getOrElse = function (default_) {
  return default_;
};

Just.prototype.getOrElse = function (_default_) {
  return this.value;
};

Nothing.prototype.orElse = function (handler) {
  return handler();
};

Just.prototype.orElse = function () {
  return this;
};

// -- JSON conversions -------------------------------------------------
Nothing.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Maybe.Nothing'
  };
};

Just.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Maybe.Just',
    value: this.value
  };
};

// -- Exports ----------------------------------------------------------
module.exports = {
  Nothing: Nothing,
  Just: Just,
  type: Maybe
};

// -- Annotations ------------------------------------------------------
if (process.env.NODE_ENV !== 'production') {
  module.exports[Symbol.for('@@meta:magical')] = {
    name: 'Maybe',
    category: 'Data Structures',
    stability: 'experimental',
    platforms: ['ECMAScript 3'],
    portability: 'Portable',
    authors: ['Quildreen Motta'],
    module: 'folktale/data/maybe/core',
    licence: 'MIT',
    seeAlso: [{
      type: 'link',
      title: 'A Monad in Practicality: First-Class Failures',
      url: 'http://robotlolita.me/2013/12/08/a-monad-in-practicality-first-class-failures.html'
    }],
    documentation: '\nThe Maybe module provides a data structure to represent values that\nmight not be present, or the result of computations that may fail.\n\nThe data structure models two different cases:\n\n -  `Just α`, which represents any value, including `null` and `undefined`.\n -  `Nothing`, which represents the abscence of a value.\n\nThe idea is that, by explicitly modelling these failures, and forcing\nthe user to deal with the failures to get to the value, we can get rid\nof common problems such as `TypeError: undefined is not a function`.\nIn other words, this data structure helps writing programs that are\ncorrect by construction, because they force the user to deal with\nall *potential* failures.\n    '
  };
}